////////////////////////////////////////
// âœ¨ Symbolmatch Parser (Pseudocode) //
////////////////////////////////////////

// Data structures

Atom        : string                 // noTrackPath symbol
SExpr       : Atom | [SExpr]             // symbolic expression (list form)
Path        : [Int]                      // index path inside S-expression
Grammar     : Map<Atom, Expr>            // grammar as collection of rules
Expr        :                            // parsing expression AST
      []                                 // empty list
    | "ATOMIC"                           // matches any atom
    | "ANY"                              // matches any S-expression
    | Array["GROUP", Expr]               // group with parentheses
    | Array["MUL", ...Expr]              // sequence of subexpressions
    | Array["ADD", ...Expr]              // ordered choice
    | Array["STAR", Expr]                // zero-or-more repetition
    | Array["ATOM", Expr]                // matches subatomic expression
    | "ONE"                              // always succeeds
    | "ZERO"                             // always fails
Result      : SExpr | Error

// Core Parsing Engine

function parse(expr: SExpr, grammar: Grammar, startRule: Atom): Result
    pattern = grammar[startRule]
    length, path, ok = match(expr, 0, pattern, grammar, [], [], false)
    if ok
        return expr
        
    else
        return Error("Parse failed", path)


// Matching Function

function match(expr: SExpr, idx: Int, pattern: Expr, grammar: Grammar, farPath: Path, curPath: Path, noTrackPath: Bool): (Int, Path, Bool)
    if not noTrackPath and compareArr(curPath, farPath) > 0
        farPath = curPath

    if expr is Atom
        expr = [expr]
        idx = 0
    
    if pattern is array
        type = pattern[0]
        
    else
        type = pattern
    
    if pattern is Atom and grammar contains pattern
        return match(expr, idx, grammar[pattern], grammar, farPath, curPath, noTrackPath)
    
    else if idx < expr.length and Array.isArray (expr[idx]) and expr[idx].length === 0 and Array.isArray (pattern) and pattern.length === 0
        return 1, farPath, true
    
    else if idx < expr.length and expr[idx] is Atom and '"' + expr[idx] + '"' == pattern
        return 1, farPath, true
    
    else if idx < expr.length and type == "ATOMIC"
        if expr[idx] is Atom
            return 1, farPath, true
            
        else
            return 0, farPath, false

    else if idx < expr.length and type == "ANY"
        return 1, farPath, true

    else if idx < expr.length and pattern[0] ==  "GROUP"
        if expr[idx] is not list
            return 0, farPath, false
        
        tmpPath = [...curPath, 0]
        length, farPath, ok = match(expr[idx], 0, pattern[1], grammar, farPath, tmpPath, noTrackPath)
            
        if not ok or length !== expr[idx].length
            return 0, farPath, false
        
        else
            return 1, farPath, true

    else if type == "ADD"
        for i = 1 to pattern.length - 1
            length, farPath, ok = match(expr, idx, pattern[i], grammar, farPath, curPath, noTrackPath)
            if ok
                return length, farPath, true
                
        return 0, farPath, false

    else if type == "MUL"
        length = 0
        for i = 1 to pattern.length - 1
            tmpPath = [...curPath.slice(0, curPath.length - 1), idx + length]
            itemLength, farPath, ok = match(expr, idx + length, pattern[i], grammar, farPath, tmpPath, noTrackPath)
            length += itemLength
            if not ok or idx + length > expr.length or itemLength == 0
                return 0, farPath, false

        return length, farPath, true

    else if type == "STAR"
        length = 0
        tmpPath = curPath
        while true
            tmpPath = [...curPath.slice(0, curPath.length - 1), idx + length]
            itemLength, farPath, ok = match(expr, idx + length, pattern[1], grammar, farPath, tmpPath, noTrackPath)
            length += itemLength
            if not ok or idx + length >= expr.length or itemLength == 0
                break

        return length, farPath, true

    else if type == "ATOM"
        if expr[idx] is Atom
            return match([expr[idx].split("")], 0, ["GROUP", pattern[1]], grammar, farPath, curPath, true)

        else
            return 0, farPath, false

    else if type == "ONE"
        return 0, farPath, true

    else if type == "ZERO"
        return 0, farPath, false

// Comparing arrays

compareArr(arr1, arr2) {
    for i = 0 to arr1.length - 1
        if i < arr2.length
            if arr1[i] < arr2[i]
                return -1
            
            else if arr1[i] > arr2[i]
                return 1

        else
            break;
    
    if arr1.length < arr2.length
        return -1

    else if arr1.length > arr2.length
        return 1
    
    else
        return 0;

