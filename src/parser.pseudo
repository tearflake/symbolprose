////////////////////////////////////////
// âœ¨ Symbolmatch Parser (Pseudocode) //
////////////////////////////////////////

// Data structures

Atom        : string                 // atomic expression
SExpr       : Atom | [SExpr]             // symbolic expression (list form)
Path        : [Int]                      // index path inside S-expression
Grammar     : Map<Atom, [Rule]>          // grammar as collection of rules
Rule        : {                          // rule
    patttern: SExpr
}

// Core Parsing Engine

function parse(expr: SExpr, grammar: Grammar): SExpr | Error
    patt = "<start>"
    path, ok = match(normalizeSExpr(expr), patt, grammar)
    if ok
        return expr
        
    else
        return Error("Parse failed", denormalizeIndexes(path))

// Matching Function

function match(expr: SExpr, patt: SExpr, grammar: Grammar): (Path, Bool)
    [mode, ok, stack, farPath] = ["fore", false, [], []]
    stack.push([-1, expr, patt, [], false])
    loop1: while mode == "fore" or stack.length > 1
        if mode == "back"
            stack.pop()
            
        [_, expr, patt, curPath, subAtomic] = stack.top()
        atomMatch = false
        if patt is Atom enclosed within quotes
            patt = normalizeAtom (patt.substring(1, patt.length - 1))

        if patt is Atom and grammar contains patt
            if mode == "back"
                if ok
                    continue loop1
                
                else
                    mode = "fore"
            
            stack.top()[0]++
            idx = stack.top()[0]
            rule = grammar[patt]
            if idx < rule.length
                stack.push([-1, expr, rule[idx].pattern, curPath, subAtomic])
                continue loop1
            
            [mode, ok] = ["back", false]
            continue loop1

        else if Array.isArray(expr) and Array.isArray(patt)
            if expr.length != patt.length
                [mode, ok] = ["back", false]
                continue loop1
            
            else
                if mode == "back"
                    if not ok
                        continue loop1
                    
                    else
                        mode = "fore"

                stack.top()[0]++
                idx = stack.top()[0]
                if idx < expr.length
                    tmpPath = [...curPath, idx]
                    if not subAtomic and compareArr(tmpPath, farPath) > 0
                        farPath = tmpPath
                    
                    if expr[idx] is array and expr[idx][0] == "ATOM"
                        subAtomic = true;
                    
                    stack.push([idx, expr[idx], patt[idx], tmpPath, subAtomic])
                    continue loop1
                    
            [mode, ok] = ["back", true]
            continue loop1
        
        else if expr is Atom and expr == patt
            atomMatch = true
        
        else if patt == "ATOMIC"
            if expr is Atom
                atomMatch = true
        
        else if patt == "ANY"
            atomMatch = true
        
        if atomMatch
            [mode, ok] = ["back", true]

        else
            [mode, ok] = ["back", false]

    return [farPath, ok]

function compareArr(arr1: [], arr2: []): Integer
    for i = 0 to arr1.length - 1
        if i < arr2.length
            if arr1[i] < arr2[i]
                return -1
            
            else if arr1[i] > arr2[i]
                return 1

        else
            break;
    
    if arr1.length < arr2.length
        return -1

    else if arr1.length > arr2.length
        return 1
    
    else
        return 0

function normalizeSExpr(expr: SExpr): SExpr
    stack = []
    car = expr
    cdr = []
    stack.push({car: expr})
    while stack.length > 0
        item = stack.pop()
        if item.car != undefined
            car = item.car;
            if car is array
                stack.push({cdr: cdr})
                cdr = [];
                for c in car
                    stack.push({car: c})
            
            else
                cdr = ["LIST", normalizeAtom(car), cdr]
        
        else
            car = cdr
            cdr = ["LIST", car, item.cdr]
    
    return (car is string) ? normalizeAtom(car) : car

function normalizeAtom(atom: String): SExpr
    cdr = [];
    for i = atom.length - 1 to 0 step -1
        cdr = ["ATOM", atom.charAt(i), cdr]
    
    return cdr

function denormalizeIndexes(nm: []): []
    dnm = []
    idx = 0
    for n in nm
        if n === 1
            dnm.push(idx)
            idx = 0
        
        else if n === 2
            idx++;
    
    if idx > 0
        dnm.push(idx)
    
    return dnm

