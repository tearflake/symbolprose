////////////////////////////////////////
// âœ¨ Symbolmatch Parser (Pseudocode) //
////////////////////////////////////////

// Data structures

Atom        : string                 // atomic expression
SExpr       : Atom | [SExpr]             // symbolic expression (list form)
Path        : [Int]                      // index path inside S-expression
Grammar     : Map<Atom, [Expr]>          // grammar as collection of rules
Expr        : {                          // pattern
    type: "NORM" | "FLAT" | "ATOM",
    pattern: SExpr
}

// Core Parsing Engine

function parse(expr: SExpr, grammar: Grammar): SExpr | Error
    pattern = "<start>"
    path, ok = match(normalizeSExpr(expr), pattern, grammar, [], [], false)
    if ok
        return expr
        
    else
        return Error("Parse failed", denormalizeIndexes(path))


// Matching Function

function match(expr: SExpr, pattern: SExpr, grammar: Grammar, farPath: Path, curPath: Path, subAtomic: Bool): (Path, Bool)
    if not subAtomic and compareArr(curPath, farPath) > 0
        farPath = curPath
    
    if pattern is Atom and grammar contains pattern
        arrPat = grammar[pattern]
        for pat in arrPat
            ok = false
            if pat.type == "ATOM"
                if subAtomic or expr is Atom
                    farPath, ok = match(subAtomic ? expr : normalizeSExpr(expr.split("")), pat.pattern, grammar, farPath, curPath, true)
            
            else if pat.type == "FLAT" and not subAtomic
                farPath, ok = match(expr, normalizeSExpr(pat.pattern), grammar, farPath, curPath, subAtomic)
                
            else if pat.type == "NORM" and not subAtomic
                farPath, ok = match(expr, pat.pattern, grammar, farPath, curPath, subAtomic)
                
            if ok
                return farPath, true
    
    else if Array.isArray(expr) and Array.isArray(pattern)
        if expr.length != pattern.length
            return farPath, false

        for idx = 0 to expr.length
            tmpPath = [...curPath, idx]
            farPath, ok = match(expr[idx], pattern[idx], grammar, farPath, tmpPath, subAtomic)
            if not ok
                return farPath, false
                
        return farPath, true
    
    else if expr is Atom and '"' + expr + '"' == pattern
        return farPath, true
    
    else if pattern == "STRING"
        if expr is Atom and expr.charAt(0) == '"' and expr.charAt(expr.length - 1) == '"'
            return farPath, true
    
    else if pattern == "IDENTIFIER"
        if expr is Atom and expr.charAt(0) != '"' and expr.charAt(expr.length - 1) != '"'
            return farPath, true
    
    else if pattern == "ATOMIC"
        if expr is Atom
            return farPath, true
    
    else if pattern == "ANY"
        return farPath, true

    return farPath, false


// Comparing arrays

compareArr(arr1, arr2) {
    for i = 0 to arr1.length - 1
        if i < arr2.length
            if arr1[i] < arr2[i]
                return -1
            
            else if arr1[i] > arr2[i]
                return 1

        else
            break;
    
    if arr1.length < arr2.length
        return -1

    else if arr1.length > arr2.length
        return 1
    
    else
        return 0;

