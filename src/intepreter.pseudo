//////////////////////////////////////////
// Symbolprose Interpreter (Pseudocode) //
//////////////////////////////////////////

// Data structures

Atom        : string                  // atoms
SExpr       : Atom | [SExpr]              // nested symbolic expressions (list form)
Env         : {
    name: string -> value: Sexpr | Graph  // enviroment variables
}
Graph       : {
    edges: {
        source:string -> [Edge]           // nodes
    },
    subgraphs : {
        name:string -> Graph              // subgraphs
    }
}
Edge        : {
    instructions: [Instr],                // instructions
    target: string                        // target node
}
Instr       : {
    name: "ASGN",
    var: SExpr,
    value: SExpr
} | {
    name: "TEST",
    lft: SExpr,
    rgt: SExpr
}

// Core interpreter

function run (graph: Graph, params: SExpr)
    env["PARAMS"] = params
    env["RESULT"] = "NIL"

    node = "BEGIN"
    loop1: while node != "END"
        if node in graph.edges
            edges = graph.edges[node]
        else
            raise error "node does not exist"
        
        loop2: for edge in edges
            for instr in edge.instructions
                else if instr.name = "ASGN"
                    env[instr.var] = evalExpr(instr.value, graph.subgraphs, env)
                
                else if instr.name = "TEST"
                    a = evalExpr(instr.lft, graph.subgraphs, env)
                    b = evalExpr(instr.rgt, graph.subgraphs, env)
                    if not deepEqual(a, b)
                        continue loop2

            node = evalExpr(edge.target, env)
            continue loop1

    return env["RESULT"]

// Expression evaluator

function evalExpr(value: SExpr, env: Env)
    if value is Atom
        if value in env
            return env[value]
        else
            return value

    value = [evalExpr(v, env) for v in value]
    
    if value[0] in internalFunc
        return internalFunc[value[0]](value, env)
    else
        return value

// Expression matching

function deepEqual(a: SExpr, b: SExpr)
    if (a is Atom) and (b is Atom)
        return (a == b) ? true : false

    else if (a is list) and (b is list) and (length(a) == length(b))
        for i in range(a)
            if not deepEqual(a[i], b[i])
                return false
        
        return true

    return false

